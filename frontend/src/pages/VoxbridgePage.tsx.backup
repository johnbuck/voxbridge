/**
 * VoxBridge Main Dashboard Page
 * Analytics at TOP, Unified Conversation Interface at BOTTOM
 * VoxBridge 2.0 - Proper conversation management integration
 */

import { useState, useRef, useCallback, useEffect } from 'react';
import { useQuery, useQueryClient } from '@tanstack/react-query';
import { api, type Message } from '@/services/api';
import { useWebSocket } from '@/hooks/useWebSocket';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { MetricsPanel } from '@/components/MetricsPanel';
import { StatusSummary } from '@/components/StatusSummary';
import { RuntimeSettings } from '@/components/RuntimeSettings';
import { ConversationList } from '@/components/ConversationList';
import { NewConversationDialog } from '@/components/NewConversationDialog';
import { AudioControls } from '@/components/AudioControls';
import { STTWaitingIndicator } from '@/components/STTWaitingIndicator';
import { AIGeneratingIndicator } from '@/components/AIGeneratingIndicator';
import { StreamingMessageDisplay } from '@/components/StreamingMessageDisplay';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Badge } from '@/components/ui/badge';
import { useToastHelpers } from '@/components/ui/toast';
import { useWebRTCAudio } from '@/hooks/useWebRTCAudio';
import { useAudioPlayback } from '@/hooks/useAudioPlayback';
import type { WebRTCAudioMessage } from '@/types/webrtc';
import { Copy, CircleCheckBig, Activity, XCircle, AlertCircle, Mic, Volume2, VolumeX, Menu, MessageSquare, Brain, Lock, Unlock, Loader2 } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { cn } from '@/lib/utils';

interface TranscriptItem {
  id: string;
  type: 'user' | 'ai';
  userId?: string;
  username?: string;
  text: string;
  timestamp: string;
  isFinal?: boolean;
}

const USER_ID = 'web_user_default'; // Hardcoded until auth is implemented

export function VoxbridgePage() {
  // Analytics state (Discord conversation monitoring)
  const [activeSpeaker, setActiveSpeaker] = useState<string | null>(null);
  const [activeSpeakerUsername, setActiveSpeakerUsername] = useState<string | null>(null);
  const [partialTranscript, setPartialTranscript] = useState<string>('');
  const [isAIGenerating, setIsAIGenerating] = useState<boolean>(false);
  const [transcriptHistory, setTranscriptHistory] = useState<TranscriptItem[]>([]);
  const [showStatistics, setShowStatistics] = useState(false);
  const seenMessageIdsRef = useRef(new Set<string>());

  // Conversation Management state
  const [sidebarOpen, setSidebarOpen] = useState(true);
  const [activeSessionId, setActiveSessionId] = useState<string | null>(null);
  const [newConversationDialogOpen, setNewConversationDialogOpen] = useState(false);
  const [speakerLocked, setSpeakerLocked] = useState(false);
  const [isUnlocking, setIsUnlocking] = useState(false);

  // Unified conversation state (adapts for Discord/WebRTC)
  const [isListening, setIsListening] = useState(false);
  const [listeningDuration, setListeningDuration] = useState(0);
  const [isVoiceAIGenerating, setIsVoiceAIGenerating] = useState(false);
  const [aiGeneratingDuration, setAiGeneratingDuration] = useState(0);
  const [streamingChunks, setStreamingChunks] = useState<string[]>([]);
  const [isStreaming, setIsStreaming] = useState(false);
  const [isSpeakerMuted, setIsSpeakerMuted] = useState(false);
  const [voicePartialTranscript, setVoicePartialTranscript] = useState<string>('');

  const queryClient = useQueryClient();
  const toast = useToastHelpers();
  const listeningStartTimeRef = useRef<number | null>(null);
  const aiStartTimeRef = useRef<number | null>(null);
  const scrollAreaRef = useRef<HTMLDivElement>(null);

  // Poll health status
  const { data: health } = useQuery({
    queryKey: ['health'],
    queryFn: () => api.getHealth(),
    refetchInterval: 2000,
  });

  // Poll detailed status
  const { data: status } = useQuery({
    queryKey: ['status'],
    queryFn: () => api.getStatus(),
    refetchInterval: 5000,
  });

  // Fetch metrics
  const { data: metrics, isLoading: isLoadingMetrics } = useQuery({
    queryKey: ['metrics'],
    queryFn: () => api.getMetrics(),
    // Metrics are refetched when AI responses complete (via invalidation)
  });

  // Fetch sessions for conversation management
  const { data: sessions = [], isLoading: isLoadingSessions, refetch: refetchSessions } = useQuery({
    queryKey: ['sessions', USER_ID],
    queryFn: () => api.getSessions(USER_ID, false, 50),
    refetchInterval: 5000, // Poll every 5 seconds
  });

  // Fetch agents for new conversation dialog
  const { data: agents = [], isLoading: isLoadingAgents } = useQuery({
    queryKey: ['agents'],
    queryFn: () => api.getAgents(),
  });

  // Fetch messages for active session
  const { data: messages = [], isLoading: isLoadingMessages } = useQuery({
    queryKey: ['messages', activeSessionId],
    queryFn: () => activeSessionId ? api.getSessionMessages(activeSessionId) : Promise.resolve([]),
    enabled: !!activeSessionId,
    refetchInterval: 2000, // Poll every 2 seconds for real-time updates
  });

  // Get active session details
  const activeSession = sessions.find((s) => s.id === activeSessionId);

  // Get agent for active session
  const activeAgent = agents.find((a) => a.id === activeSession?.agent_id);

  // Audio playback hook for TTS (web voice chat)
  const audioPlayback = useAudioPlayback({
    autoPlay: true,
    onPlaybackStart: () => console.log('ðŸ”Š Playing TTS audio'),
    onPlaybackEnd: () => console.log('âœ… TTS playback complete'),
    onError: (error) => toast.error('Audio playback failed', error),
  });

  // Handle WebRTC audio messages (web voice chat with database persistence)
  const handleWebRTCAudioMessage = useCallback(
    async (message: WebRTCAudioMessage) => {
      switch (message.event) {
        case 'partial_transcript':
          // Update voice chat partial transcript
          setVoicePartialTranscript(message.data.text || '');
          setIsListening(true);
          if (!listeningStartTimeRef.current) {
            listeningStartTimeRef.current = Date.now();
          }
          break;

        case 'final_transcript':
          // Clear voice chat partial transcript
          setVoicePartialTranscript('');
          setIsListening(false);
          const listeningDurationMs = listeningStartTimeRef.current
            ? Date.now() - listeningStartTimeRef.current
            : 0;
          listeningStartTimeRef.current = null;
          setListeningDuration(0);

          // Save user message to database (if we have an active session)
          if (activeSessionId) {
            try {
              await api.addMessage(activeSessionId, {
                role: 'user',
                content: message.data.text || '',
              });
              queryClient.invalidateQueries({ queryKey: ['messages', activeSessionId] });
            } catch (error) {
              console.error('[WebRTC] Failed to save user message:', error);
              toast.error('Failed to save message', error instanceof Error ? error.message : 'Unknown error');
            }
          }

          // Start AI generation indicator for voice chat
          setIsVoiceAIGenerating(true);
          aiStartTimeRef.current = Date.now();
          break;

        case 'ai_response_chunk':
          // Stream AI response chunks for voice chat
          setStreamingChunks((prev) => [...prev, message.data.text || '']);
          setIsStreaming(true);

          // Real-time update in messages list (if we have an active session)
          if (activeSessionId) {
            queryClient.setQueryData(['messages', activeSessionId], (oldData: Message[] | undefined) => {
              if (!oldData) return oldData;

              const lastMessage = oldData[oldData.length - 1];
              if (lastMessage && lastMessage.role === 'assistant') {
                // Append to existing assistant message
                return [
                  ...oldData.slice(0, -1),
                  {
                    ...lastMessage,
                    content: lastMessage.content + (message.data.text || ''),
                  },
                ];
              } else {
                // Create new assistant message
                return [
                  ...oldData,
                  {
                    id: Date.now(), // Temporary ID
                    session_id: activeSessionId,
                    role: 'assistant',
                    content: message.data.text || '',
                    timestamp: new Date().toISOString(),
                    audio_duration_ms: null,
                    tts_duration_ms: null,
                    llm_latency_ms: null,
                    total_latency_ms: null,
                  },
                ];
              }
            });
          }
          break;

        case 'ai_response_complete':
          // Complete AI response for voice chat
          setIsStreaming(false);
          setStreamingChunks([]);
          setIsVoiceAIGenerating(false);
          aiStartTimeRef.current = null;
          setAiGeneratingDuration(0);

          // Save final AI message to database (if we have an active session)
          if (activeSessionId) {
            try {
              await api.addMessage(activeSessionId, {
                role: 'assistant',
                content: message.data.text || '',
              });
              queryClient.invalidateQueries({ queryKey: ['messages', activeSessionId] });
            } catch (error) {
              console.error('[WebRTC] Failed to save AI message:', error);
              toast.error('Failed to save AI response', error instanceof Error ? error.message : 'Unknown error');
            }
          }

          // Play buffered TTS audio if not muted
          if (!isSpeakerMuted) {
            await audioPlayback.completeAudio();
          } else {
            console.log('ðŸ”‡ Speaker muted, discarding TTS audio');
            audioPlayback.stop();
          }
          break;

        case 'tts_start':
          console.log('ðŸ”Š TTS generation started');
          break;

        case 'tts_complete':
          console.log(`âœ… TTS complete (${message.data.duration_s?.toFixed(2)}s)`);
          break;

        case 'error':
          console.error('[VoiceChat] Backend error:', message.data.message);
          toast.error('Voice Chat Error', message.data.message || 'Unknown error');
          break;

        default:
          console.warn('[VoiceChat] Unknown message event:', message.event);
      }
    },
    [activeSessionId, audioPlayback, isSpeakerMuted, queryClient, toast]
  );

  // Handle binary audio chunks from TTS (web voice chat)
  const handleBinaryMessage = useCallback(
    (audioData: Uint8Array) => {
      if (!isSpeakerMuted) {
        console.log(`ðŸŽµ Buffering audio chunk: ${audioData.length} bytes`);
        audioPlayback.addAudioChunk(audioData);
      } else {
        console.log('ðŸ”‡ Speaker muted, discarding audio chunk');
      }
    },
    [audioPlayback, isSpeakerMuted]
  );

  // Handle WebRTC errors (web voice chat)
  const handleAudioError = useCallback(
    (error: string) => {
      toast.error('Audio Error', error);
    },
    [toast]
  );

  // WebRTC Audio Hook (web voice chat - uses active session)
  const {
    isMuted,
    toggleMute,
    connectionState,
    permissionError,
    isRecording,
  } = useWebRTCAudio({
    sessionId: activeSessionId, // Use active session ID from conversation management
    onMessage: handleWebRTCAudioMessage,
    onBinaryMessage: handleBinaryMessage,
    onError: handleAudioError,
    autoStart: false,
    timeslice: 100,
  });


  // Handle WebSocket messages (Discord conversation monitoring)
  const handleMessage = useCallback((message: any) => {
    // VoxBridge 2.0: Handle agent CRUD events (real-time updates)
    if (message.event === 'agent_created' || message.event === 'agent_updated' || message.event === 'agent_deleted') {
      queryClient.invalidateQueries({ queryKey: ['agents'] });
      return;
    }

    switch (message.event) {
      case 'speaker_started':
        setActiveSpeaker(message.data.userId);
        setActiveSpeakerUsername(message.data.username);
        break;
      case 'speaker_stopped':
        setActiveSpeaker(null);
        setActiveSpeakerUsername(null);
        setPartialTranscript('');
        break;
      case 'partial_transcript':
        setPartialTranscript(message.data.text);
        break;
      case 'final_transcript':
        // Clear active speaker section immediately
        setActiveSpeaker(null);
        setActiveSpeakerUsername(null);
        setPartialTranscript('');

        // Start AI generation indicator
        setIsAIGenerating(true);

        const userMessageId = `user-${message.data.userId}-${message.data.timestamp}-${message.data.text.substring(0, 50)}`;

        if (seenMessageIdsRef.current.has(userMessageId)) {
          console.log('[Final Transcript] Duplicate message, skipping:', userMessageId);
          break;
        }

        console.log('[Final Transcript] Adding new message:', userMessageId);
        seenMessageIdsRef.current.add(userMessageId);

        setTranscriptHistory((prev) => {
          const newItem: TranscriptItem = {
            id: userMessageId,
            type: 'user',
            userId: message.data.userId,
            username: message.data.username,
            text: message.data.text,
            timestamp: message.data.timestamp,
          };
          return [newItem, ...prev].slice(0, 100);
        });
        break;
      case 'ai_response':
        // Clear AI generation indicator
        setIsAIGenerating(false);

        const messageId = message.data.id;
        console.log('[AI Response] Received:', { id: messageId, text: message.data.text });

        if (seenMessageIdsRef.current.has(messageId)) {
          console.log('[AI Response] Duplicate message, skipping:', messageId);
          break;
        }

        console.log('[AI Response] Adding new message:', messageId);
        seenMessageIdsRef.current.add(messageId);

        setTranscriptHistory((prev) => {
          const newItem: TranscriptItem = {
            id: messageId,
            type: 'ai',
            text: message.data.text,
            timestamp: message.data.timestamp,
            isFinal: message.data.isFinal,
          };
          return [newItem, ...prev].slice(0, 100);
        });

        if (message.data.isFinal) {
          console.log('[Metrics] Refetching metrics after AI response completion');
          queryClient.invalidateQueries({ queryKey: ['metrics'] });
        }
        break;
      case 'status_update':
        break;
    }
  }, [queryClient]);

  // WebSocket for real-time updates (Discord conversation monitoring)
  const { isConnected: wsConnected } = useWebSocket('/ws/events', {
    onMessage: handleMessage
  });

  // Auto-select first session on load
  useEffect(() => {
    if (sessions.length > 0 && !activeSessionId) {
      setActiveSessionId(sessions[0].id);
    }
  }, [sessions, activeSessionId]);

  // Fetch speaker lock status when agent has Discord plugin
  useEffect(() => {
    if (!activeAgent?.plugins?.discord?.enabled) {
      // Reset speaker lock state if no Discord plugin
      setSpeakerLocked(false);
      return;
    }

    // Fetch status immediately
    const fetchSpeakerStatus = async () => {
      try {
        const statusData = await api.getStatus();
        setSpeakerLocked(statusData.speaker?.locked || false);
      } catch (error) {
        console.error('[VoxBridge] Failed to fetch speaker status:', error);
      }
    };

    fetchSpeakerStatus();

    // Poll every 3 seconds while agent has Discord plugin
    const interval = setInterval(fetchSpeakerStatus, 3000);
    return () => clearInterval(interval);
  }, [activeAgent]);

  // Update listening duration (web voice chat)
  useEffect(() => {
    if (isListening && listeningStartTimeRef.current) {
      const interval = setInterval(() => {
        setListeningDuration(Date.now() - listeningStartTimeRef.current!);
      }, 100);
      return () => clearInterval(interval);
    }
  }, [isListening]);

  // Update AI generating duration (web voice chat)
  useEffect(() => {
    if (isVoiceAIGenerating && aiStartTimeRef.current) {
      const interval = setInterval(() => {
        setAiGeneratingDuration(Date.now() - aiStartTimeRef.current!);
      }, 100);
      return () => clearInterval(interval);
    }
  }, [isVoiceAIGenerating]);

  // Conversation Management Handlers

  // Handle create conversation
  const handleCreateConversation = useCallback(
    async (agentId: string, title?: string) => {
      try {
        const newSession = await api.createSession({
          user_id: USER_ID,
          agent_id: agentId,
          title: title || null,
          session_type: 'web',
        });

        // Refetch sessions and select new one
        await refetchSessions();
        setActiveSessionId(newSession.id);
        toast.success('Conversation created', `Started new conversation with agent`);
      } catch (error) {
        toast.error('Failed to create conversation', error instanceof Error ? error.message : 'Unknown error');
        throw error;
      }
    },
    [refetchSessions, toast]
  );

  // Handle delete conversation
  const handleDeleteSession = useCallback(
    async (sessionId: string) => {
      if (!confirm('Delete this conversation? This cannot be undone.')) {
        return;
      }

      try {
        await api.deleteSession(sessionId);

        // If we deleted the active session, select another
        if (sessionId === activeSessionId) {
          const remainingSessions = sessions.filter((s) => s.id !== sessionId);
          setActiveSessionId(remainingSessions.length > 0 ? remainingSessions[0].id : null);
        }

        await refetchSessions();
        toast.success('Conversation deleted');
      } catch (error) {
        toast.error('Failed to delete conversation', error instanceof Error ? error.message : 'Unknown error');
      }
    },
    [activeSessionId, sessions, refetchSessions, toast]
  );

  // Handle select session
  const handleSelectSession = useCallback((sessionId: string) => {
    setActiveSessionId(sessionId);
  }, []);

  // Handle unlock speaker
  const handleUnlockSpeaker = useCallback(async () => {
    setIsUnlocking(true);
    try {
      const result = await api.unlockSpeaker();
      setSpeakerLocked(false);
      toast.success('Speaker unlocked', result.previousSpeaker ? `Unlocked ${result.previousSpeaker}` : undefined);
    } catch (error) {
      toast.error('Failed to unlock speaker', error instanceof Error ? error.message : 'Unknown error');
    } finally {
      setIsUnlocking(false);
    }
  }, [toast]);

  const copyToClipboard = async (text: string) => {
    try {
      await navigator.clipboard.writeText(text);
      toast.success('Copied!', 'Text copied to clipboard');
    } catch (err) {
      console.error('Failed to copy:', err);
      toast.error('Copy failed', err instanceof Error ? err.message : 'Unknown error');
    }
  };

  const shortenUrl = (url: string, maxLength: number = 35) => {
    if (url.length <= maxLength) return url;
    const start = url.substring(0, maxLength - 3);
    return `${start}...`;
  };

  // Format timestamp for messages
  const formatTimestamp = (timestamp: string) => {
    const date = new Date(timestamp);
    return date.toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' });
  };

  // Status helper functions for dynamic service status displays
  const getDiscordStatus = () => {
    if (!health?.botReady) {
      return {
        color: 'text-red-600 dark:text-red-400',
        icon: <XCircle className="w-4 h-4" />,
        text: 'Offline',
        info: 'Not Ready'
      };
    }
    if (activeSpeaker) {
      return {
        color: 'text-purple-600 dark:text-purple-400',
        icon: <Mic className="w-4 h-4" />,
        text: 'Active',
        info: status?.voice.channelName || 'Processing audio'
      };
    }
    if (status?.voice.connected) {
      return {
        color: 'text-green-600 dark:text-green-400',
        icon: <CircleCheckBig className="w-4 h-4" />,
        text: 'Ready',
        info: status.voice.channelName || 'Connected'
      };
    }
    return {
      color: 'text-yellow-600 dark:text-yellow-400',
      icon: <AlertCircle className="w-4 h-4" />,
      text: 'Ready',
      info: 'Not in voice channel'
    };
  };

  const getWhisperXStatus = () => {
    if (!status?.whisperx.serverConfigured) {
      return {
        color: 'text-red-600 dark:text-red-400',
        icon: <XCircle className="w-4 h-4" />,
        text: 'Not Configured',
        info: 'No server URL set'
      };
    }
    if (activeSpeaker && partialTranscript) {
      return {
        color: 'text-blue-600 dark:text-blue-400',
        icon: <Activity className="w-4 h-4 animate-pulse" />,
        text: 'Processing',
        info: 'Transcribing speech'
      };
    }
    return {
      color: 'text-green-600 dark:text-green-400',
      icon: <CircleCheckBig className="w-4 h-4" />,
      text: 'Ready',
      info: status?.devices?.whisperx || 'STT available'
    };
  };

  const getChatterboxStatus = () => {
    if (!status?.services.chatterbox) {
      return {
        color: 'text-red-600 dark:text-red-400',
        icon: <XCircle className="w-4 h-4" />,
        text: 'Offline',
        info: 'Service not responding'
      };
    }
    // Check if there's a recent non-final AI response (indicates generating)
    const isGenerating = transcriptHistory.length > 0 &&
      transcriptHistory[0].type === 'ai' &&
      !transcriptHistory[0].isFinal;

    if (isGenerating) {
      return {
        color: 'text-blue-600 dark:text-blue-400',
        icon: <Activity className="w-4 h-4 animate-pulse" />,
        text: 'Generating',
        info: 'Creating audio'
      };
    }
    return {
      color: 'text-green-600 dark:text-green-400',
      icon: <CircleCheckBig className="w-4 h-4" />,
      text: 'Ready',
      info: status?.devices?.chatterbox || 'TTS available'
    };
  };

  const getN8nStatus = () => {
    if (!status?.services.n8nWebhook) {
      return {
        color: 'text-red-600 dark:text-red-400',
        icon: <XCircle className="w-4 h-4" />,
        text: 'Not Set',
        info: 'No webhook configured'
      };
    }
    return {
      color: 'text-green-600 dark:text-green-400',
      icon: <CircleCheckBig className="w-4 h-4" />,
      text: 'Configured',
      info: 'Webhook ready'
    };
  };

  return (
    <div className="min-h-screen bg-page-background p-6">
      <div className="max-w-7xl mx-auto space-y-6">
        {/* ============================================ */}
        {/* ANALYTICS SECTION (TOP) */}
        {/* ============================================ */}

        {/* Header */}
        <div className="text-center relative">
          <h1 className="text-4xl font-bold">VoxBridge Dashboard</h1>
          <p className="text-muted-foreground mt-1">
            Real-time voice bridge monitoring and control
          </p>

          {/* Absolutely positioned settings button */}
          <div className="absolute right-0 sm:right-4 top-12">
            <RuntimeSettings />
          </div>
        </div>

        {/* Summary Statistics */}
        <StatusSummary metrics={metrics} isLoadingMetrics={isLoadingMetrics} wsConnected={wsConnected} />

        {/* Show/Hide Stats Button */}
        <div className="flex justify-center">
          <button
            onClick={() => setShowStatistics(!showStatistics)}
            className="px-3 py-1 text-xs bg-primary/10 hover:bg-primary/20 text-primary rounded-full transition-colors duration-300"
          >
            {showStatistics ? 'Hide Stats' : 'Show Stats'}
          </button>
        </div>

        {/* Metrics Panel (Conditional) */}
        {showStatistics && <MetricsPanel />}

        {/* Service Status Grid */}
        <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
          <CardHeader className="cursor-pointer" onClick={() => setVoiceChatExpanded(!voiceChatExpanded)}>
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-3">
                <Mic className="w-5 h-5 text-primary" />
                <CardTitle>Voice Chat</CardTitle>
                {isRecording && (
                  <div className="flex items-center gap-2">
                    <div className="w-2 h-2 bg-red-500 rounded-full animate-pulse" />
                    <span className="text-xs text-red-500 font-medium">Recording</span>
                  </div>
                )}
                {connectionState === 'connected' && !isRecording && (
                  <div className="flex items-center gap-2">
                    <div className="w-2 h-2 bg-green-500 rounded-full" />
                    <span className="text-xs text-green-500 font-medium">Connected</span>
                  </div>
                )}
              </div>
              <div className="flex items-center gap-3">
                <AudioControls
                  isMuted={isMuted}
                  onToggleMute={toggleMute}
                  connectionState={connectionState}
                  permissionError={permissionError}
                  isRecording={isRecording}
                />
                <Button
                  variant={isSpeakerMuted ? 'outline' : 'default'}
                  size="icon"
                  onClick={(e) => {
                    e.stopPropagation();
                    setIsSpeakerMuted(!isSpeakerMuted);
                  }}
                  title={isSpeakerMuted ? 'Unmute speaker' : 'Mute speaker'}
                >
                  {isSpeakerMuted ? <VolumeX className="h-4 w-4" /> : <Volume2 className="h-4 w-4" />}
                </Button>
                {voiceChatExpanded ? (
                  <ChevronUp className="w-5 h-5 text-muted-foreground" />
                ) : (
                  <ChevronDown className="w-5 h-5 text-muted-foreground" />
                )}
              </div>
            </div>
          </CardHeader>

          {voiceChatExpanded && (
            <CardContent className="space-y-4">
              {/* Permission Error */}
              {permissionError && (
                <div className="flex items-start gap-3 p-4 bg-red-500/10 border border-red-500/20 rounded-lg">
                  <AlertCircle className="h-5 w-5 text-red-500 flex-shrink-0 mt-0.5" />
                  <div className="flex-1 min-w-0">
                    <p className="text-sm font-medium text-red-500 mb-1">Microphone Permission Required</p>
                    <p className="text-xs text-muted-foreground">{permissionError}</p>
                  </div>
                </div>
              )}

              {/* STT Waiting Indicator */}
              <STTWaitingIndicator
                isListening={isListening}
                duration={listeningDuration}
                partialTranscript={voicePartialTranscript}
              />

              {/* AI Generating Indicator */}
              <AIGeneratingIndicator
                isGenerating={isVoiceAIGenerating}
                duration={aiGeneratingDuration}
              />

              {/* Streaming Message Display */}
              {isStreaming && (
                <StreamingMessageDisplay
                  chunks={streamingChunks}
                  isStreaming={isStreaming}
                  agentName={status?.bot.username || 'AI Assistant'}
                />
              )}

              {/* Connection Status */}
              <div className="flex items-center justify-between p-4 bg-muted/50 rounded-lg">
                <div className="flex items-center gap-3">
                  <div className={`w-3 h-3 rounded-full ${
                    connectionState === 'connected' ? 'bg-green-500' :
                    connectionState === 'connecting' ? 'bg-yellow-500 animate-pulse' :
                    'bg-red-500'
                  }`} />
                  <div>
                    <p className="text-sm font-medium">WebRTC Connection</p>
                    <p className="text-xs text-muted-foreground capitalize">{connectionState}</p>
                  </div>
                </div>
                <div className="text-right">
                  <p className="text-xs text-muted-foreground">Microphone: {isMuted ? 'Muted' : 'Active'}</p>
                  <p className="text-xs text-muted-foreground">Speaker: {isSpeakerMuted ? 'Muted' : 'Active'}</p>
                </div>
              </div>
            </CardContent>
          )}
        </Card>

        {/* Summary Statistics */}
        <StatusSummary metrics={metrics} isLoadingMetrics={isLoadingMetrics} wsConnected={wsConnected} />

        {/* Show/Hide Stats Button */}
        <div className="flex justify-center">
          <button
            onClick={() => setShowStatistics(!showStatistics)}
            className="px-3 py-1 text-xs bg-primary/10 hover:bg-primary/20 text-primary rounded-full transition-colors duration-300"
          >
            {showStatistics ? 'Hide Stats' : 'Show Stats'}
          </button>
        </div>

        {/* Metrics Panel (Conditional) */}
        {showStatistics && <MetricsPanel />}

        {/* Connection Status Grid */}
        <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
          <Card>
            <CardHeader className="pb-3">
              <CardTitle className="text-sm font-medium">Discord Bot</CardTitle>
            </CardHeader>
            <CardContent>
              {(() => {
                const statusInfo = getDiscordStatus();
                return (
                  <>
                    <div className={`flex items-center gap-2 text-sm font-semibold ${statusInfo.color}`}>
                      {statusInfo.icon}
                      <span>{statusInfo.text}</span>
                    </div>
                    <p className="text-xs text-muted-foreground mt-1">
                      {statusInfo.info}
                    </p>
                    {status?.bot.id && (
                      <div className="flex items-center gap-1 mt-1">
                        <p className="text-xs text-muted-foreground font-mono flex-1" title={status.bot.id}>
                          {status.bot.id}
                        </p>
                        <button
                          onClick={() => copyToClipboard(status.bot.id)}
                          className="p-1 hover:bg-muted rounded"
                          title="Copy Bot ID"
                        >
                          <Copy className="w-3 h-3" />
                        </button>
                      </div>
                    )}
                  </>
                );
              })()}
            </CardContent>
          </Card>

          <Card>
            <CardHeader className="pb-3">
              <CardTitle className="text-sm font-medium">WhisperX</CardTitle>
            </CardHeader>
            <CardContent>
              {(() => {
                const statusInfo = getWhisperXStatus();
                return (
                  <>
                    <div className={`flex items-center gap-2 text-sm font-semibold ${statusInfo.color}`}>
                      {statusInfo.icon}
                      <span>{statusInfo.text}</span>
                    </div>
                    <p className="text-xs text-muted-foreground mt-1">
                      {statusInfo.info}
                    </p>
                    {status?.whisperx.serverUrl && (
                      <div className="flex items-center gap-1 mt-1">
                        <p className="text-xs text-muted-foreground truncate flex-1" title={status.whisperx.serverUrl}>
                          {shortenUrl(status.whisperx.serverUrl)}
                        </p>
                        <button
                          onClick={() => copyToClipboard(status.whisperx.serverUrl)}
                          className="p-1 hover:bg-muted rounded"
                          title="Copy URL"
                        >
                          <Copy className="w-3 h-3" />
                        </button>
                      </div>
                    )}
                  </>
                );
              })()}
            </CardContent>
          </Card>

          <Card>
            <CardHeader className="pb-3">
              <CardTitle className="text-sm font-medium">Chatterbox TTS</CardTitle>
            </CardHeader>
            <CardContent>
              {(() => {
                const statusInfo = getChatterboxStatus();
                return (
                  <>
                    <div className={`flex items-center gap-2 text-sm font-semibold ${statusInfo.color}`}>
                      {statusInfo.icon}
                      <span>{statusInfo.text}</span>
                    </div>
                    <p className="text-xs text-muted-foreground mt-1">
                      {statusInfo.info}
                    </p>
                    {status?.services.chatterboxUrl && (
                      <div className="flex items-center gap-1 mt-1">
                        <p className="text-xs text-muted-foreground truncate flex-1" title={status.services.chatterboxUrl}>
                          {shortenUrl(status.services.chatterboxUrl)}
                        </p>
                        <button
                          onClick={() => copyToClipboard(status.services.chatterboxUrl)}
                          className="p-1 hover:bg-muted rounded"
                          title="Copy URL"
                        >
                          <Copy className="w-3 h-3" />
                        </button>
                      </div>
                    )}
                  </>
                );
              })()}
            </CardContent>
          </Card>

          <Card>
            <CardHeader className="pb-3">
              <CardTitle className="text-sm font-medium">n8n Webhook</CardTitle>
            </CardHeader>
            <CardContent>
              {(() => {
                const statusInfo = getN8nStatus();
                return (
                  <>
                    <div className={`flex items-center gap-2 text-sm font-semibold ${statusInfo.color}`}>
                      {statusInfo.icon}
                      <span>{statusInfo.text}</span>
                    </div>
                    <p className="text-xs text-muted-foreground mt-1">
                      {statusInfo.info}
                    </p>
                    {status?.services.n8nWebhookUrl && (
                      <div className="flex items-center gap-1 mt-1">
                        <p className="text-xs text-muted-foreground truncate flex-1" title={status.services.n8nWebhookUrl}>
                          {shortenUrl(status.services.n8nWebhookUrl)}
                        </p>
                        <button
                          onClick={() => copyToClipboard(status.services.n8nWebhookUrl)}
                          className="p-1 hover:bg-muted rounded"
                          title="Copy URL"
                        >
                          <Copy className="w-3 h-3" />
                        </button>
                      </div>
                    )}
                  </>
                );
              })()}
            </CardContent>
          </Card>
        </div>

        {/* Conversation Card (Discord conversation monitoring) */}
        <Card className="flex flex-col">
          <CardHeader>
            <CardTitle>Discord Conversation</CardTitle>
          </CardHeader>
          <CardContent className="flex flex-col flex-1 min-h-0 space-y-4">
            {/* Active Speaker Section - Using STT Indicator */}
            {activeSpeaker && (
              <div className="pb-4 shrink-0">
                <div className="flex items-center gap-2 mb-3">
                  <div className="w-3 h-3 bg-green-500 rounded-full animate-pulse"></div>
                  <span className="font-medium">{activeSpeakerUsername || activeSpeaker}</span>
                </div>
                {partialTranscript && (
                  <div className="flex justify-start">
                    <div className="max-w-[80%] p-3 rounded-lg bg-primary/10 border border-primary/20">
                      <p className="text-sm text-muted-foreground italic">{partialTranscript}</p>
                    </div>
                  </div>
                )}
              </div>
            )}

            {/* AI Generation Indicator - Using new component style */}
            {isAIGenerating && (
              <div className="pb-4 shrink-0">
                <div className="flex justify-end">
                  <div className="max-w-[80%] p-3 rounded-lg bg-purple-500/10 border border-purple-500/20">
                    <div className="flex gap-1">
                      <div className="w-2 h-2 bg-purple-400 rounded-full animate-bounce" style={{ animationDelay: '0ms' }}></div>
                      <div className="w-2 h-2 bg-purple-400 rounded-full animate-bounce" style={{ animationDelay: '150ms' }}></div>
                      <div className="w-2 h-2 bg-purple-400 rounded-full animate-bounce" style={{ animationDelay: '300ms' }}></div>
                    </div>
                  </div>
                </div>
              </div>
            )}

            {/* Conversation History */}
            {transcriptHistory.length > 0 ? (
              <div className="flex-1 overflow-y-auto space-y-3 min-h-0">
                {transcriptHistory.map((item) => (
                  <div
                    key={item.id}
                    className={`flex ${item.type === 'ai' ? 'justify-end' : 'justify-start'}`}
                  >
                    <div
                      className={`max-w-[80%] p-3 rounded-lg ${
                        item.type === 'user'
                          ? 'bg-primary/10 border border-primary/20'
                          : 'bg-purple-500/10 border border-purple-500/20'
                      }`}
                    >
                      <div className="flex items-center justify-between mb-1 gap-2">
                        <span className={`text-xs font-medium ${
                          item.type === 'user' ? 'text-primary' : 'text-purple-400'
                        }`}>
                          {item.type === 'user' ? item.username : (status?.bot.username || 'AI Assistant')}
                        </span>
                        <span className="text-xs text-muted-foreground whitespace-nowrap">
                          {new Date(item.timestamp).toLocaleTimeString()}
                        </span>
                      </div>
                      <p className="text-sm">{item.text}</p>
                    </div>
                  </div>
                ))}
              </div>
            ) : (
              !activeSpeaker && (
                <div className="text-center py-12 text-muted-foreground flex-1">
                  <p className="text-sm">Waiting for audio...</p>
                  <p className="text-xs mt-1">
                    Speak in the Discord voice channel to see transcriptions
                  </p>
                </div>
              )
            )}
          </CardContent>
        </Card>
      </div>
    </div>
  );
}
